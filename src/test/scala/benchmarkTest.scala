/*
 * Copyright (C) 2022  Xo√°n C. Pardo
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package gal.udc.gac.lsgo2013

import org.scalatest.funsuite.AnyFunSuite

import scala.concurrent.duration._
import util.DataFileReader.{CDataFileOps, ElementReader}
import util.SearchSpace._
import util.Random.reals
import util.duration
import Benchmark.{Subcomponents => Subcomps, _}

class benchmarkTest extends AnyFunSuite {
  // dimensions and tolerance
  val dim2 = 905  // dimension for functions with overlapping parts
  val tolerance: Double = 1.0E-10 // maximum allowed round-off error for a comparison to be valid
  // path to the files generated by the c++ validation tests
  val path: String = "/tmp"
  // LSGO benchmark functions
  val lsgo2013 = LSGO2013()

  /**
   *  Basic benchmark functions
   */
  object Wrappers {
    // wrappers defined to compare the basic functions and the transformations
    // that are included as part of the basic function implementation in the original C++ code
    def elliptic(e: Element): Double = Elliptic()(e.oscillation)
    def rastrigin(e: Element): Double = Rastrigin()(e.oscillation.asymmetry(0.2).illConditioning(10))
    def ackley(e: Element): Double = Ackley()(e.oscillation.asymmetry(0.2).illConditioning(10))
    def schwefel(e: Element): Double = Schwefel()(e.oscillation.asymmetry(0.2))
  }
  val basicFuns = Vector(Sphere(), Wrappers.elliptic(_), Wrappers.rastrigin(_), Wrappers.ackley(_), Wrappers.schwefel(_), Rosenbrock())
  val basicFunName = Vector("sphere", "elliptic", "rastrigin", "ackley", "schwefel", "rosenbrock")

  /** check functions ------------------------------------------------------------------------------------------ */

  object Checkers {
    /** check a sample of elements with all the benchmark functions
     *
     * @param x the samples (the same sample is used for all functions if only one is passed)
     * @param expected the expected fitness values
     * @return true if the evaluation of all the samples equals (with tolerance) the expected results
     */
    def check(x: Vector[Element], expected: Element): Boolean = lsgo2013.indices.map { id =>
      val xx = if (x.size == 1) x(0) else x(id) // the sample of the current function
      check(id + 1, Vector(xx), Vector(expected(id)))
    }.forall(_ == true)

    /** check a sample of elements with a given benchmark function by id
     *
     * @param id the benchamrk function ID (1 to 15)
     * @param x the samples
     * @param expected the expected fitness values
     * @return true if the evaluation of all the samples equals (with tolerance) the expected results
     */
    def check(id: Int, x: Vector[Element], expected: Element): Boolean = {
      print(s"f$id: ")
      check(lsgo2013(id - 1), x, expected)
    }

    /** check a sample of elements with a given fitness function
     *
     * @param f the fitness function
     * @param x the samples
     * @param expected the expected fitness values
     * @return true if the evaluation of all the samples equals (with tolerance) the expected results
     */
     def check(f: FitnessFunction, x: Vector[Element], expected: Element): Boolean = {
      val results = x.zipWithIndex.map {
        case (point, i) =>
          val result = f(point)
          val error = if (expected(i) == 0.0) math.abs(result - expected(i)) else math.abs(result - expected(i)) / expected(i)
          (i, result, error)
      }
      println(s"exact(${results.count(_._3 == 0.0) * 100 / results.size}%), max_error(${results.map(_._3).max})")
      // results.map(x => println(f"${x._1 + 1}: ${x._2}%.25E | ${x._3}"))
      // results.filter(_._3 != 0.0).foreach(x => println(s"${x._1 + 1}: ${x._2} | ${x._3}"))
      results.forall(_._3 <= tolerance)
    }
  }

  /** Reading samples from file -------------------------------------------------------------------------------- */

  object Samples extends ElementReader {

    /** Read samples from a file by function (generated with the C++ validation test)
     *
     * For each of the functions tested there are n samples of size dim and their n expected results
     * stored in the file
     *
     * @param file the path to the file
     * @param funs the number of functions tested
     * @return a vector containing the samples and expected results for all the functions tested
     */
    def readByFun(file: String, funs: Int) : Vector[Element] = {
      val data: Element = readElement(file)
      val n = data(0).toInt // first value in file is the number of samples
      assert(data.size == funs * n * (dim + 1) + 1)
      println(s"[Samples: $n]")
      // split samples and expected solutions in data
      data.drop(1).grouped(n*(dim+1)).toVector
    }

    /** Read samples from a file by sample (generated with the C++ validation test)
     *
     * There are n samples of size dim and for each sample the expected results of all the functions tested
     * stored in the file
     *
     * @param file the path to the file
     * @param funs the number of functions tested
     * @return a vector containing a tuple for each sample and its expected results for all the functions tested
     */
    def readBySample(file: String, funs: Int) : Vector[(Element, Element)] = {
      val data: Element = readElement(file)
      val n = data(0).toInt // first value in file is the number of samples
      assert(data.size == n * (dim + funs) + 1)
      //println(s"[Samples: $n]")
      // split samples and expected solutions in data
      data.drop(1).grouped(dim + lsgo2013.size).map(group =>
        (group.take(dim), group.takeRight(lsgo2013.size))).toVector
    }
  }

  /** tests ---------------------------------------------------------------------------------------------------- */

  import Checkers._

  // Test all benchmark functions at zero
  test("Test zero") {

    // expected values (taken from the C++ implementation)
    val expected = Vector(
      2.09833896353343505859E+11,
      4.76203116166061372496E+04,
      2.17290025349525564025E+01,
      1.07955147656065953125E+14,
      4.84191483329246416688E+07,
      1.07773246530947787687E+06,
      9.93826981321072625000E+14,
      5.72227150187806412800E+18,
      6.00160320250193595886E+09,
      9.81154816487000137568E+07,
      1.04485201647212016000E+17,
      1.71135423694972143555E+12,
      8.27380048985966720000E+16,
      4.40797968120962457600E+18,
      2.39389233661550150000E+15)

    // zero vector
    val zero: Element = Vector.fill(dim)(0.0)

    assert(check(Vector(zero), expected))
  }

  // Test all benchmark functions at optimum
  test("Test optimum") {

    // expected values (taken from the C++ implementation)
    val expected = Vector(
      0.0,
      0.0,
      4.44089209850062616169E-16,
      0.0,
      0.0,
      2.21147654753865975808E-11,
      0.0,
      0.0,
      0.0,
      2.01047792178124918860E-09,
      0.0,
      9.99000000000000000000E+02,
      0.0,
      1.19722589191424442368E+21,
      0.0)

    // reads optimum
    val optimum = {
      object Reader extends CDataFileOps
      (1 to lsgo2013.size).map(i => Reader.readOptimal(s"F$i")).toVector
    }

    assert(check(optimum, expected))
  }

  // Test basic functions at random samples
  test("Test basic functions") {

    val samples = Samples.readByFun(path + "/lsgo-basicfuns.txt", basicFuns.size)

    val checks = samples.zipWithIndex.map { case (group, id) =>
      // split random samples
      val (points, expected) = group.grouped(dim+1).map(sample =>
        (sample.take(dim), sample.last)).toVector.unzip
      print(s"[Function: ${basicFunName(id)}] ")
      check(basicFuns(id), points, expected)
    }

    assert(checks.forall(_ == true))
  }

  // Test benchmark functions at random samples by sample
  // (evaluate all functions with each sample)
  test("Test random") {

    val samples = Samples.readBySample(path + "/lsgo-random.txt", lsgo2013.size)

    val checks = samples.zipWithIndex.map { case ((sample, expected), id) =>
      // bound random samples to search space limits for every benchmark function
      val bounded = lsgo2013.indices.map(i =>
        sample.bound(BoundFunction.scale)(lsgo2013(i).info)).toVector
      println(s"[Sample: ${id+1}]")
      check(bounded, expected)
    }

    assert(checks.forall(_ == true))
  }

  // Test benchmark functions at random samples by function
  // (evaluate all samples with each function)
  test("Test random by function") {

    val samples = Samples.readByFun(path + "/lsgo-randombyfun.txt", lsgo2013.size)

    val checks = samples.zipWithIndex.map { case (group, id) =>
      // split and bound random samples to search space limits
      val (bounded, expected) = group.grouped(dim+1).map(sample =>
        (sample.take(dim).bound(BoundFunction.scale)(lsgo2013(id).info), sample.last)).toVector.unzip
      //println(s"[Function: ${id+1}]")
      check(id+1, bounded, expected)
    }

    assert(checks.forall(_ == true))
  }

  // Test running times of each transformation
  test("Running times") {

    // dummy benchmark function
    class TestFun(fun: Int)
      extends BenchmarkFunction(s"F$fun", lsgo2013(fun-1).info)
        with Subcomps {

      val size = if (fun == 13 || fun == 14) dim2 else dim

      override def apply(e: Element): Double = 0.0 // not used in testing

      // run the test with the given number of samples and repetitions
      def run(samples: Int = 1000, repeats: Int = 100): Seq[Element] = (1 to samples).map { _ =>
          // Random vector scaled to search space bounds
          val random: Element = Vector.fill(size)(reals.sample()).bound(BoundFunction.scale)(info)
          // run the transformations on the element measuring the duration
          val (d, total) = duration {(
              duration { (1 to repeats).foreach(_ => random.shift(xopt)) }.toUnit(NANOSECONDS),
              duration { (1 to repeats).foreach(_ => random.oscillation()) }.toUnit(NANOSECONDS),
              duration { (1 to repeats).foreach(_ => random.asymmetry(0.2)) }.toUnit(NANOSECONDS),
              duration { (1 to repeats).foreach(_ => random.illConditioning(10)) }.toUnit(NANOSECONDS),
              duration { (1 to repeats).foreach(_ => random.permute(p)) }.toUnit(NANOSECONDS),
              duration { (1 to repeats).foreach(_ => nonSeparable(random)) }.toUnit(NANOSECONDS),
              if (fun == 14)
                duration { (1 to repeats).foreach(_ => nonSeparableConflicting(random, 5)) }.toUnit(NANOSECONDS)
              else 0.0
          )}
          d.productIterator.map(d => d.asInstanceOf[Double] * 100 / total.toUnit(NANOSECONDS)).toVector
      }
    }
    object TestFun {
      def apply(fun: Int): TestFun = new TestFun(fun)
    }

    // test params
    val ids = Vector(4, 5, 6, 7, 8, 9, 10, 11, 13, 14)  // benchmark functions with subcomponents
    val repeats = 100
    val samples = 100
    val name = Vector("xopt", "Tosz", "Tasy", "lamb", "perm", "nsep", "conf") // transformations names

    // test
    println(s"[Samples: $samples, Repeats: $repeats]")
    ids.foreach {id =>
      val f = TestFun(id) // function to test
      f.run(1, 10)  // initial warm up
      val times = f.run(samples, repeats)

      // print times
    /*times.foreach(d => {
      val s = d.map(t => f"${t}%2.0f%%")
      println(s.mkString(" "))
    })*/

      // print summary
      println(s"=== F$id ===")
      name.indices.foreach(i => {
        val measure = times.map(t => t(i))
        println(f"${name(i)}: ${measure.min}%2.0f%%, ${measure.sum / measure.size}%2.0f%%, ${measure.max}%2.0f%%")
      })
    }

    true
  }
}
